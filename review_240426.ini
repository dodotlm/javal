## 자바
# 1. review + preview
1. 어제 배웠던 내용은 github를 실질적으로 어떻게 사용하는지에 대해서 알아봄
2. 특히 소스트리를 이용한 커밋을 배웠는데 일단은 디렉토리 상 꼬이는게 발생 할 수 있으니 당분간 github에 올리는 것은 bash로 하는 것이 좋겠다.
3. 병합에 대해서 공부를 했는데 일단 소스트리를 사용한다고 했을 때 기본적인 골자는 working space -> staging area -> local repos -> remote repos 단계를 기억할 것
4. 그래도 소스트리는 일괄적 add 기능이 있고 commit과 push를 동시에 할 수 있으므로 bash보다 훨씬 효율적이라고 할 수 있다.
5. 브랜치는 커밋(버전)을 분기점으로 삼아서 main브랜치 이외의 브랜치를 만들 수 있다. 물론 중심은 main 브랜치가 되어야 한다.
6. main 브랜치의 내용과 분화해서 나간 브랜치의 내용이 다를 경우 병합에 어려움을 겪을 수 있는데 이 경우 병합을 우선 분화된 브랜치에서 진행하고 분화되어 병합된 브랜치를 그 이후에 main브랜치에 병합하면 된다.
7. 위와 같은 병합 방법과 pull_request 방법이 있는데 이는 github의 gui를 이용하여 하는 것이고 좀 더 정중하고 예의바르게 다른 팀원들의 동의를 구해가면서 병합을 진행 할 수 있게 되는 것이라고 할 수 있다.

8. 자바는 늘 먹던 맛.
9. 팁을 알아갑니다. syso + ctrl + space 를 치면 system.out.println() 구문이 자동으로 완성된다.
10. 패키지 >> 클래스 >> 메소드 //여기서의 메소드는 C 언어에서의 함수와 같다고 보면 이해가 편하다. 하지만 자바와 C언어는 다르므로 확실히 구분하도록하자. 굳이 구분하자면 메서드는 멤버 함수라고 할 수 있다.
11. 함수는 어디서든 호출이 가능하지만 메서드는 엄연히 클래스에 속해 있는 것으로 구분둬야 한다.




## 2. 변수, 그리고 기본 자료형

1. 변수에는 지역(로컬)변수 / 클래스변수 / static변수 가 있다.
2. static 변수는 전역변수로서 어디서든 접근이 가능한 변수로 본다. 이와 반대로 지역변수는 그 지역 내에서만 쓸 수 있는 변수, 클래스 변수는 그 클래스 내에서만 유효한 변수라는 뜻으로 해석하면 된다.
2-1. 클래스 변수는 두가지로 나뉘는데 "클래스 변수"와 "인스턴스 변수"로 나뉜다.
2-1-1. 클래스 변수는 앞에 static이 붙고 인스턴스 변수는 붙지 않는다. 
3. String같은 참조 자료형은 대문자로 시작한다. int와 같은 기본 자료형은 소문자로 시작한다.

4. 기본 자료형 타입에는 byte(1byte), char(2byte), short(2byte), int(4byte), long(8byte), float(4byte), double(8byte), boolean(1byte) 가 있다.
4-1. char는 아스키코드/유니코드를 이용할 때 사용된다. 유니코드에는 음수가 없기에 양수만 저장한다.
4-2. short는 char와 표현 할 수 있는 양은 같은데 범위가 다르다. 얘는 음수도 된다.
4-3. int 정수를 나타낸다. 요즘엔 long을 더 많이 쓴다고 한다.
4-4. long을 쓸 때 int 범위 보다 큰 값을 할당 받을 때는 뒤에 'l'을 붙여줘야 한다. 안 그럼 오류남ㅇㅇ
4-5. float는 실수를 나타낸다. 요즘은 double을 더 많이 쓴다.
4-6. double은 실수를 나타낸다. 이걸 더 많이 쓴다. 
4-7. boolean 타입은 true false값만 저장할 수 있다.

4-8. 자바만의 특색인지는 모르겠지만 큰 게 작은 것을 품을 수는 있는데 작은 게 큰 걸 품으려고 하면 아예 안된다. 예를 들어 float를 double로 바꾸는 건 되는데 double을 float로 바꾸면 오류가 났다. 깐간한 언어이다.
4-8-0. <[(중요)]> "위의 예시는 자동형변환에서는 오류나는 행위인데 강제형변환 처리해주면 오류도 안나고 됨."
4-8-1. byte(1byte) -> short(2byte) -> int(4byte) -> long(8byte) -> float(4byte) -> double(8byte) 여기서 역으로 가는 것은 오류를 초래 할 수도 있다.
4-8-2. 다만 위의 관계와는 별개로 자연수 > 정수 > 실수 > String(문자열) 순으로 우선 형변환된다. 즉 long과 float이 있으면 long이 float보다 더 크더라도 float으로 형변환 된다는 것이다.
4-8-3. 또한 이들은 모두 String과 조합 할 수 있다. 물론 조합한 결과값은 String(문자열)이 된다.
5. 문자열 결합 연산자 "+"가 있다. 문자열끼리 서로서로 더해주는 느낌이다.

6. 상수는 final로 표기한다. 한번 초기화가 되면 더 이상 밑에서 고칠 수 없다. 보통 대문자로 쓰며 중간에 언더바를 하나 넣어준다.
6-1. 이렇게 [final int BARO_HEBOM = 1000;]

7. 연산자는 특별할 것은 없다. 전위/후위 증감 연산자나 삼항 연산자 정도만 생각해두면 된다.
7-1. 전위 연산자가 증감을 바로 표현해주고 후위 연산자는 증감을 바로 표현해주지 않는 것을 까먹지 않으면 된다.
7-1-1. 후위 연산자가 헷갈릴 것인데 정말 강력하고 컴펙트하게 정의하면 "그 줄에서는 증감이 반영 안되지만 그 줄을 벗어나는 순간 증감이 반영된다."

7-2. 또한 삼항 연산자(...) A ? B :C면 A의 A의 true는 B A의 false는 C라는 것을 생각해 두면 된다.
7-2-1. EX) true ? 1 : 5 면 출력값은 1  //  false ? 1 : 4 면 출력값은 4
7-2-2 중첩 가능하므로 생각 잘해야 함.
7-3. 당연하지만 "=="은 같다고 "!="이 다르다 이다. !=을  까먹는 경우가 나올 수 있으니 주의.
7-3-1. "=="으로 비교 할 수 있는 것은 기본 자료형 뿐이다. 참조 자료형은 object에서 상속받아 오버라이드 된 equals라는 메소드를 상속 받아야 한다.
7-3-2. 사용법은 [ 비교할_문자열의_변수_1.equals(비교할_문자열의_변수_2) ]

8. "단항 연산자"가 최우선이고 그다음 "이항 연산자" 그 다음 "삼항 연산자"가 실행된다.
9. "산술 연산자"가 최우선이고 그다음 "비교 연산자" 그 다음 "논리 연산자" 그 다음 "대입 연산자" 순으로 실행된다.


## 3. 조건문과 반복문 짚고 넘어갈 점.
1. 꼭 조건 다 맞추고 코드 다 짰는데 결과 값 안나온다고 당황하지 마라. 출력문 안 적은거다ㅋ
2. 조건이 길 때는 무조건 괄호로 묶어두자
3. 얼리 리턴 방식에 대해서 생각을 해보자. 
4. for문에서 증감식이 없는 경우가 있다.
for(int h = 0; h <= 100; ) {
        //3의 배수의 합
        sum += h;
        h += 3;
    }
<< 이런식으로 증감식을 조건문에 넣지 않고 할 수도 있다.






